<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Solmemetics</title>
  <style>
    html { scroll-behavior: smooth; }
    body {
      background: linear-gradient(180deg, #000000, #1a1a1a);
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
      position: relative;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: -100px;
      animation: fadeIn 1s ease-in;
    }
    @keyframes fadeIn {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    img {
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
    }
    .connect-button {
      padding: 12px 24px;
      font-size: 16px;
      background: white;
      color: black;
      border: none;
      border-radius: 9999px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .connect-button:hover { background-color: #e0e0e0; }
    .nav-button {
      font-size: 16px;
      color: white;
      font-weight: bold;
      background: none;
      border: none;
      cursor: pointer;
      transition: color 0.3s;
    }
    .nav-button:hover { color: #cccccc; }
    #status {
      margin-top: 20px;
      font-size: 16px;
      color: #ccc;
    }
    #controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #nav-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 10px;
    }
    #balance { margin-right: 10px; }
    .social-links {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    .social-icon {
      width: 48px;
      height: 48px;
      transition: transform 0.3s ease, opacity 0.3s ease;
    }
    .social-icon.jupiter-icon { width: 57.6px; height: 57.6px; }
    .social-icon:hover { opacity: 0.8; transform: scale(1.1); }
    .donation-text {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 14px;
      color: #ccc;
      font-family: Arial, sans-serif;
    }
    .copyable { cursor: pointer; text-decoration: underline; }
    .copyable:hover { color: #e0e0e0; }
    .tagline {
      font-size: 18px;
      color: #ccc;
      margin-bottom: 20px;
      min-height: 24px;
    }
    .feedback-container {
      margin-top: 20px;
      width: 100%;
      max-width: 400px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .feedback-input, .feedback-textarea {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
      margin-bottom: 10px;
      background: #2a2a2a;
      color: white;
    }
    .feedback-textarea { height: 100px; resize: vertical; }
    .feedback-button {
      padding: 10px 20px;
      font-size: 16px;
      background: white;
      color: black;
      border: none;
      border-radius: 9999px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .feedback-button:hover { background-color: #e0e0e0; }
    .feedback-button:disabled { background-color: #666; cursor: not-allowed; }
    #feedback-list {
      margin-top: 20px;
      width: 100%;
      max-width: 400px;
      text-align: left;
      color: #ccc;
    }
    .feedback-item { border-bottom: 1px solid #444; padding: 10px 0; }
  </style>
</head>
<body>
  <div id="nav-controls">
    <button id="home" class="nav-button">Homepage</button>
    <button id="whitepaper" class="nav-button">Whitepaper</button>
  </div>
  <div id="controls">
    <div id="balance">Balance: 0 SMM</div>
    <button id="connect" class="connect-button">Connect</button>
  </div>
  <div class="content">
    <img src="your-image.png" alt="Coming Soon" />
    <div class="tagline" id="tagline"></div>
    <div class="social-links">
      <a href="https://t.me/solmemeticsTG" target="_blank" title="Join our Telegram">
        <img src="telegram.png" alt="Telegram" class="social-icon" />
      </a>
      <a href="https://jup.ag/tokens/BbDK2SdFKstCuCjF152jWaRVmJMV7hHUW4xYvdMbjups" target="_blank" title="Trade on Jupiter">
        <img src="jupiter.png" alt="Jupiter" class="social-icon jupiter-icon" />
      </a>
      <a href="https://x.com/solmemetics" target="_blank" title="Follow us on Twitter">
        <img src="twitter.png" alt="Twitter" class="social-icon" />
      </a>
    </div>
    <div class="feedback-container">
      <input id="username-input" class="feedback-input" placeholder="Username (optional)" disabled />
      <textarea id="feedback-input" class="feedback-textarea" placeholder="Enter your feedback (requires 1000 SMM tokens)" disabled></textarea>
      <button id="feedback-submit" class="feedback-button" disabled>Submit Feedback</button>
      <button id="view-feedback" class="feedback-button" style="display: none;">View Feedback</button>
    </div>
    <div id="feedback-list"></div>
    <div id="status"></div>
  </div>
  <div class="donation-text">
    Help fund the project by donating Solana/USDC to <span id="donation-address" class="copyable">solmemetics.sol</span>
  </div>

  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <script src="https://unpkg.com/@solana/spl-token@0.4.8/lib/index.umd.min.js"></script>
  <script>
    // Fallback for spl-token
    window.splToken = window.splToken || {};
    window.splToken.getAssociatedTokenAddress = window.splToken.getAssociatedTokenAddress || function() { throw new Error("spl-token not loaded"); };
    window.splToken.createAssociatedTokenAccountInstruction = window.splToken.createAssociatedTokenAccountInstruction || function() { throw new Error("spl-token not loaded"); };
    window.splToken.createTransferInstruction = window.splToken.createTransferInstruction || function() { throw new Error("spl-token not loaded"); };

    // Check if libraries loaded
    if (!window.solanaWeb3 || !window.splToken.getAssociatedTokenAddress || !window.CryptoJS) {
      document.getElementById("status").textContent = "Error: Failed to load required libraries (web3.js, spl-token, or CryptoJS). Check console for details.";
      console.error("Library loading issue: solanaWeb3:", !!window.solanaWeb3, "splToken:", !!window.splToken.getAssociatedTokenAddress, "CryptoJS:", !!window.CryptoJS);
      throw new Error("Library loading failed");
    }

    const { PublicKey, Connection } = solanaWeb3;
    const { getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, createTransferInstruction } = splToken;
    const TOKEN_MINT = new PublicKey("BbDK2SdFKstCuCjF152jWaRVmJMV7hHUW4xYvdMbjups");
    const TOTAL_SUPPLY = 100000000;
    const ONE_PERCENT = TOTAL_SUPPLY * 0.01;
    const FEEDBACK_FEE = 1000;
    const RECIPIENT_ADDRESS = new PublicKey("Cj64jfCQ2dR5Utf62nMnmEq8fjerAk4u1mZY1Hv53QZA");
    const LAUNCH_WALLET = "Cj64jfCQ2dR5Utf62nMnmEq8fjerAk4u1mZY1Hv53QZA";
    const ENCRYPTION_KEY = "solmemetics-secret-2025"; // Replace with secure key
    const RPC_ENDPOINT = "https://silent-fluent-diamond.solana-mainnet.quiknode.pro/bdf6a6133f8736f5bf9097f4628841fe18b60bcc/"; // Replace with your RPC URL

    const connectBtn = document.getElementById("connect");
    const statusDiv = document.getElementById("status");
    const balanceDiv = document.getElementById("balance");
    const homeBtn = document.getElementById("home");
    const whitepaperBtn = document.getElementById("whitepaper");
    const donationAddress = document.getElementById("donation-address");
    const taglineDiv = document.getElementById("tagline");
    const usernameInput = document.getElementById("username-input");
    const feedbackInput = document.getElementById("feedback-input");
    const feedbackSubmit = document.getElementById("feedback-submit");
    const viewFeedbackBtn = document.getElementById("view-feedback");
    const feedbackList = document.getElementById("feedback-list");

    homeBtn.addEventListener("click", () => window.location.href = "index.html");
    whitepaperBtn.addEventListener("click", () => window.location.href = "whitepaper.html");

    donationAddress.addEventListener("click", () => {
      navigator.clipboard.writeText("solmemetics.sol").then(() => {
        const originalText = donationAddress.textContent;
        donationAddress.textContent = "Copied!";
        setTimeout(() => donationAddress.textContent = originalText, 2000);
      }).catch(err => {
        console.error("Copy failed:", err);
        donationAddress.textContent = "Copy failed!";
        setTimeout(() => donationAddress.textContent = "solmemetics.sol", 2000);
      });
    });

    const taglines = [
      "Empowering the future of memes on Solana",
      "Join the Solmemetics revolution!",
      "Your gateway to meme-driven crypto",
      "What are you talking about",
      "I smell good",
      "Probably nothing",
      "Damn, you're looking good today",
      "Did you buy yet?"
    ];

    function getRandomTagline(excludeIndex) {
      let newIndex;
      do {
        newIndex = Math.floor(Math.random() * taglines.length);
      } while (newIndex === excludeIndex && taglines.length > 1);
      return { index: newIndex, tagline: taglines[newIndex] };
    }

    function updateTagline() {
      const lastIndex = localStorage.getItem("lastTaglineIndex");
      const { index, tagline } = getRandomTagline(lastIndex ? parseInt(lastIndex) : null);
      taglineDiv.textContent = tagline;
      localStorage.setItem("lastTaglineIndex", index);
    }

    updateTagline();
    setInterval(updateTagline, 50000);

    function encryptFeedback(data) {
      try {
        return CryptoJS.AES.encrypt(JSON.stringify(data), ENCRYPTION_KEY).toString();
      } catch (err) {
        console.error("Encryption failed:", err);
        statusDiv.textContent = "Error: Failed to encrypt feedback.";
        return null;
      }
    }

    async function submitFeedback(publicKey, username, feedback) {
      const encryptedData = encryptFeedback({ username, feedback });
      if (!encryptedData) return;
      try {
        const response = await fetch("/feedback", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ publicKey: publicKey.toBase58(), encryptedData, timestamp: new Date().toISOString() })
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to submit feedback`);
        statusDiv.textContent = "Feedback submitted successfully!";
        usernameInput.value = "";
        feedbackInput.value = "";
      } catch (err) {
        console.error("Feedback submission error:", err);
        statusDiv.textContent = `Error: Failed to submit feedback - ${err.message}`;
      }
    }

    async function fetchFeedback() {
      try {
        const response = await fetch("/get-feedback");
        if (!response.ok) throw new Error(`HTTP ${response.status}: Failed to fetch feedback`);
        const feedbackData = await response.json();
        feedbackList.innerHTML = "";
        if (feedbackData.length === 0) {
          feedbackList.innerHTML = "<p>No feedback available.</p>";
          return;
        }
        feedbackData.forEach(item => {
          try {
            const decrypted = CryptoJS.AES.decrypt(item.encryptedData, ENCRYPTION_KEY).toString(CryptoJS.enc.Utf8);
            const { username, feedback } = JSON.parse(decrypted);
            const div = document.createElement("div");
            div.className = "feedback-item";
            div.innerHTML = `<strong>${username || "Anonymous"}</strong> (${item.publicKey.slice(0, 6)}...): ${feedback} <br><small>${new Date(item.timestamp).toLocaleString()}</small>`;
            feedbackList.appendChild(div);
          } catch (err) {
            console.error("Decryption error for item:", item, err);
            feedbackList.innerHTML += `<p>Error decrypting feedback from ${item.publicKey.slice(0, 6)}...</p>`;
          }
        });
      } catch (err) {
        console.error("Fetch feedback error:", err);
        statusDiv.textContent = `Error: Failed to fetch feedback - ${err.message}`;
      }
    }

    async function transferFeedbackFee(connection, provider, fromPubkey) {
      try {
        const tokenProgramId = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
        const fromTokenAccount = (await connection.getParsedTokenAccountsByOwner(fromPubkey, { mint: TOKEN_MINT })).value.find(
          acc => acc.account.data.parsed.info.mint === TOKEN_MINT.toBase58()
        );
        if (!fromTokenAccount) {
          statusDiv.textContent = "Error: No SMM token account found.";
          return false;
        }
        const toTokenAccount = await getAssociatedTokenAddress(TOKEN_MINT, RECIPIENT_ADDRESS, false, tokenProgramId);
        const transaction = new solanaWeb3.Transaction();
        const accountInfo = await connection.getAccountInfo(toTokenAccount);
        if (!accountInfo) {
          transaction.add(createAssociatedTokenAccountInstruction(fromPubkey, toTokenAccount, RECIPIENT_ADDRESS, TOKEN_MINT, tokenProgramId));
        }
        const balance = fromTokenAccount.account.data.parsed.info.tokenAmount.uiAmount;
        if (balance < FEEDBACK_FEE) {
          statusDiv.textContent = `Error: Insufficient balance. Need ${FEEDBACK_FEE} SMM, but only ${balance} SMM available.`;
          return false;
        }
        transaction.add(createTransferInstruction(fromTokenAccount.pubkey, toTokenAccount, fromPubkey, FEEDBACK_FEE * 10 ** 9, []));
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;
        const signedTransaction = await provider.signTransaction(transaction);
        const txId = await connection.sendRawTransaction(signedTransaction.serialize());
        await connection.confirmTransaction({ signature: txId, blockhash, lastValidBlockHeight });
        statusDiv.textContent = "Token transfer successful!";
        return true;
      } catch (err) {
        console.error("Token transfer error:", err);
        statusDiv.textContent = `Error: Failed to transfer SMM tokens - ${err.message}`;
        return false;
      }
    }

    async function checkPhantomAndConnect() {
      if (!window.solana || !window.solana.isPhantom) {
        statusDiv.textContent = "Phantom Wallet not found. Please install Phantom.";
        window.open("https://phantom.app/", "_blank");
        usernameInput.disabled = true;
        feedbackInput.disabled = true;
        feedbackSubmit.disabled = true;
        viewFeedbackBtn.style.display = "none";
        return;
      }
      try {
        const provider = window.solana;
        await provider.connect({ onlyIfTrusted: false });
        const publicKey = provider.publicKey;
        statusDiv.textContent = `Connected: ${publicKey.toBase58().slice(0, 6)}...`;
        usernameInput.disabled = false;
        feedbackInput.disabled = false;
        feedbackSubmit.disabled = false;
        viewFeedbackBtn.style.display = publicKey.toBase58() === LAUNCH_WALLET ? "block" : "none";
        const connection = new Connection(RPC_ENDPOINT, { commitment: "confirmed" });
        try {
          new PublicKey(TOKEN_MINT);
        } catch (formatError) {
          console.error("Invalid mint address format:", formatError);
          statusDiv.textContent = "Error: SMM token mint address is malformed.";
          return;
        }
        statusDiv.textContent += " Validating SMM token mint...";
        try {
          const mintInfo = await connection.getParsedAccountInfo(TOKEN_MINT);
          if (!mintInfo.value) {
            statusDiv.textContent = "Error: SMM token mint does not exist on Mainnet.";
            console.error("Mint not found:", TOKEN_MINT.toBase58());
            return;
          }
          if (mintInfo.value.data.program !== "spl-token") {
            statusDiv.textContent = "Error: Address is not a valid SPL token mint for SMM.";
            console.error("Invalid token mint program:", TOKEN_MINT.toBase58());
            return;
          }
        } catch (mintError) {
          console.error("Mint validation error:", mintError);
          statusDiv.textContent = `Error: Failed to validate SMM token mint - ${mintError.message}`;
          return;
        }
        statusDiv.textContent += " Checking SMM token balance...";
        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(publicKey, { mint: TOKEN_MINT });
        let tokenBalance = 0;
        for (const { account } of tokenAccounts.value) {
          const info = account.data.parsed.info;
          if (info.mint === TOKEN_MINT.toBase58()) {
            tokenBalance = parseFloat(info.tokenAmount.uiAmount);
            break;
          }
        }
        const balanceString = tokenBalance.toString();
        const [integerPart, decimalPart] = balanceString.split('.');
        let displayBalance = integerPart;
        if (decimalPart) {
          const trimmedDecimals = decimalPart.replace(/0+$/, '').slice(0, 9);
          if (trimmedDecimals) displayBalance += '.' + trimmedDecimals;
        }
        balanceDiv.textContent = `Balance: ${displayBalance || 0} SMM`;
        statusDiv.textContent = getCompliment(tokenBalance);
        function getCompliment(balance) {
          if (balance < 1 && balance > 0) return "That's not even one token, are you sure you have the right wallet?";
          if (balance === 1) return "Hmm, just 1 SMM? Curious, why so few?";
          if (balance > 1 && balance <= 10) {
            const compliments = [
              "Nice start with your SMM! Maybe take it slow in crypto?",
              "A few SMM - great taste, but crypto might not be your full-time gig yet!",
              "You’ve got some SMM! Perhaps crypto’s a gentle hobby for now?"
            ];
            return compliments[Math.floor(Math.random() * compliments.length)];
          }
          if (balance > 10 && balance <= 100) {
            const compliments = [
              "Wow, over 10 SMM! You’re doing well - maybe crypto isn’t your calling, but it’s fun!",
              "More than 10 SMM? Impressive, though you might enjoy it more outside crypto!",
              "Over 10 SMM - nice stash! Crypto might be a sideline for you, no pressure!"
            ];
            return compliments[Math.floor(Math.random() * compliments.length)];
          }
          if (balance > 100 && balance <= ONE_PERCENT) {
            const compliments = [
              "Over 100 SMM? That’s cool! Have you thought about grabbing more?",
              "Nice, more than 100 SMM! Ever considered adding to your stack?",
              "100+ SMM - awesome! Maybe pick up a few more when you can?"
            ];
            return compliments[Math.floor(Math.random() * compliments.length)];
          }
          if (balance > ONE_PERCENT) return "With over 1% of SMM (1 million+), you’re a powerhouse! You could shape the project’s direction - exciting times ahead!";
          return "No tokens found in this wallet, this definitely can't be the right wallet";
        }
        feedbackSubmit.onclick = async () => {
          const feedback = feedbackInput.value.trim();
          const username = usernameInput.value.trim();
          if (!feedback) {
            statusDiv.textContent = "Error: Feedback cannot be empty.";
            return;
          }
          statusDiv.textContent = "Processing token transfer...";
          const transferSuccess = await transferFeedbackFee(connection, provider, publicKey);
          if (transferSuccess) {
            statusDiv.textContent = "Submitting feedback...";
            await submitFeedback(publicKey, username || "Anonymous", feedback);
          }
        };
        viewFeedbackBtn.onclick = async () => {
          statusDiv.textContent = "Fetching feedback...";
          await fetchFeedback();
        };
        connectBtn.textContent = "Disconnect";
        connectBtn.removeEventListener("click", checkPhantomAndConnect);
        const disconnectHandler = async () => {
          try {
            await provider.disconnect();
            connectBtn.textContent = "Connect";
            balanceDiv.textContent = "Balance: 0 SMM";
            statusDiv.textContent = "Disconnected from Phantom Wallet.";
            usernameInput.disabled = true;
            feedbackInput.disabled = true;
            feedbackSubmit.disabled = true;
            viewFeedbackBtn.style.display = "none";
            feedbackList.innerHTML = "";
            connectBtn.removeEventListener("click", disconnectHandler);
            connectBtn.addEventListener("click", checkPhantomAndConnect);
          } catch (err) {
            console.error("Disconnect error:", err);
            statusDiv.textContent = `Error: Failed to disconnect - ${err.message}`;
            connectBtn.textContent = "Connect";
            connectBtn.removeEventListener("click", disconnectHandler);
            connectBtn.addEventListener("click", checkPhantomAndConnect);
          }
        };
        connectBtn.addEventListener("click", disconnectHandler);
      } catch (err) {
        console.error("Connection error:", err);
        statusDiv.textContent = `Error: Failed to connect - ${err.message}`;
        usernameInput.disabled = true;
        feedbackInput.disabled = true;
        feedbackSubmit.disabled = true;
        viewFeedbackBtn.style.display = "none";
      }
    }

    connectBtn.addEventListener("click", checkPhantomAndConnect);

    window.addEventListener("load", async () => {
      if (!window.solana || !window.solana.isPhantom) {
        statusDiv.textContent = "Phantom Wallet not found. Please install Phantom.";
        usernameInput.disabled = true;
        feedbackInput.disabled = true;
        feedbackSubmit.disabled = true;
        viewFeedbackBtn.style.display = "none";
        return;
      }
      if (!window.solanaWeb3 || !window.splToken.getAssociatedTokenAddress || !window.CryptoJS) {
        statusDiv.textContent = "Error: Failed to load required libraries (web3.js, spl-token, or CryptoJS). Check console for details.";
        usernameInput.disabled = true;
        feedbackInput.disabled = true;
        feedbackSubmit.disabled = true;
        viewFeedbackBtn.style.display = "none";
        return;
      }
      try {
        const provider = window.solana;
        if (provider.isConnected) await checkPhantomAndConnect();
      } catch (err) {
        console.error("Auto-connect error:", err);
        statusDiv.textContent = `Error: Auto-connect failed - ${err.message}`;
      }
    });
  </script>
</body>
</html>